// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
#include "Robot.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
DriveBase* Robot::driveBase = 0;
Stacker* Robot::stacker = 0;
Grabber* Robot::grabber = 0;
Arduino* Robot::arduino = 0;
OI* Robot::oi = 0;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
PowerDistributionPanel* Robot::pdp = 0;
StackerControlTask* Robot::stackerControl = 0;
SqueezeControlTask* Robot::squeezeControl = 0;

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	driveBase = new DriveBase();
	stacker = new Stacker();
	grabber = new Grabber();
	arduino = new Arduino();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	lw = LiveWindow::GetInstance();

	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	File = RAWCConstants::getInstance();
	driveBase->SetWheelbase(19.5/2, 28.0, 19.5/2);
	FLOffset = File->getValueForKey("FLOff");
	FROffset = File->getValueForKey("FROff");
	RLOffset = File->getValueForKey("RLOff");
	RROffset = File->getValueForKey("RROff");
	driveBase->SetOffsets(FLOffset, FROffset, RLOffset, RROffset);

	driveBase->frontLeft->Enable();
	driveBase->frontRight->Enable();
	driveBase->rearLeft->Enable();
	driveBase->rearRight->Enable();

	pdp=new PowerDistributionPanel();

	stackerControl = new StackerControlTask();
	stackerControl->Start();
	squeezeControl = new SqueezeControlTask();
	squeezeControl->Start();
	centerTote = new CenterToteTask();


	autoChooser = new SendableChooser();
	autoChooser->AddDefault("01. ThreeToteStack", (void*)ThreeToteStacker);
	autoChooser->AddObject("02. ContainerGrabber", (void*)ContainerGrabber);
	autoChooser->AddObject("03. ToteAndContainer", (void*)ToteAndContainer);
	autoChooser->AddObject("04. DriveForward", (void*)DriveForward);
	autoChooser->AddObject("05. DoNothing", (void*)DoNothing);
	SmartDashboard::PutData("Autonomous Chooser", autoChooser);
  }

void Robot::DisabledInit(){
	stackerControl->SetAutoSpeed(false);
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();

	SmartDashboard::PutBoolean("LiftSmokedB",!stackerControl->GetSmoked());
	SendArduinoOutputs();

	/*******************SmartDashboard*********************/
	if(oi->getDriverRight()->GetRawButton(7))
		StackerSMDB();
	if(oi->getDriverRight()->GetRawButton(8))
		DriveBaseSMDB();
	if(oi->getDriverRight()->GetRawButton(9))
		SystemSMDB();

	/******************Keeping Talons Alive*****************/
	driveBase->frontLeftSteer->Set(0);
	driveBase->frontRightSteer->Set(0);
	driveBase->rearLeftSteer->Set(0);
	driveBase->rearRightSteer->Set(0);
	stacker->liftFrontRight->Set(0);
	stacker->liftFrontLeft->Set(12);
	stacker->dart->SetControlMode(CANSpeedController::kPosition);
	stacker->dart->Set(stacker->dart->GetPosition());
	stacker->squeeze->Set(0);

}

void Robot::AutonomousInit() {
    autoProgram = static_cast<AutoProgram>((int)(autoChooser->GetSelected()));
    genericAutoProgram.clear();
	switch(autoProgram) {

	case ThreeToteStacker:
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(WaitForLift);
		genericAutoProgram.push_back(Turn90);
		genericAutoProgram.push_back(DriveForward15);
		genericAutoProgram.push_back(ForwardToTote);
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(WaitForLiftCoast);
//		genericAutoProgram.push_back(DrivePastContainer);
//		genericAutoProgram.push_back(ForwardToThirdTote);
		genericAutoProgram.push_back(DriveForward15);
		genericAutoProgram.push_back(ForwardToTote);
		genericAutoProgram.push_back(PickThirdTote);
		genericAutoProgram.push_back(WaitForLiftFinal);
		genericAutoProgram.push_back(DriveToAutoZone1);
		genericAutoProgram.push_back(DriveToAutoZone2);
		genericAutoProgram.push_back(DropTotes);
		genericAutoProgram.push_back(WaitForDart);
		genericAutoProgram.push_back(PickThirdTote);
		genericAutoProgram.push_back(WaitForLiftFinal);
		genericAutoProgram.push_back(DartBack);
		genericAutoProgram.push_back(End);

		stackerControl->SetLiftPosition(0);
		stackerControl->SetAutoSpeed(true);
		stacker->liftFrontRight->SetPosition(-428);
		break;

	case ContainerGrabber:
		genericAutoProgram.push_back(ExtendGrabber);
		genericAutoProgram.push_back(RetractGrabber);
		genericAutoProgram.push_back(DriveOverBump);
		genericAutoProgram.push_back(DriveAwayFromBumpWithCont);
		genericAutoProgram.push_back(FinishTurn);
		genericAutoProgram.push_back(End);
		break;

	case DriveForward:
		genericAutoProgram.push_back(DriveToAutoZone1);
		genericAutoProgram.push_back(DriveToAutoZone2);
		genericAutoProgram.push_back(End);
		break;

	case ToteAndContainer:
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(IndexUp);
		genericAutoProgram.push_back(WaitForLift);
		genericAutoProgram.push_back(DriveToAutoZone1);
		genericAutoProgram.push_back(DriveToAutoZone2);
		genericAutoProgram.push_back(End);
		break;

	case DoNothing:
		genericAutoProgram.push_back(End);
		break;
	}
	autoStart = GetClock();
	autoStepi = 0;
	autoStep = genericAutoProgram[autoStepi];
	autoStepTime = GetClock();
	onTargetCounter = 0;
	robotAngle = 0;
	driveBase->imu->ZeroYaw();
	stackerControl->SetDartClosedLoop(true);
	stacker->dart->SetControlMode(CANSpeedController::kPosition);
	stacker->dart->Set(stacker->dart->GetPosition());}

void Robot::AutonomousPeriodic() {
	SmartDashboard::PutBoolean("LiftSmokedB",!stackerControl->GetSmoked());
	SendArduinoOutputs();

	float x = 0;
	float y = 0;
	bool useDriveParams;

	switch(autoStep) {
	case IndexUp:
		SmartDashboard::PutString("AutoStep", "IndexUp");
		x = 0;
		y = 0;
		useDriveParams = true;
		stackerControl->IncLiftPosition();
		autoStepComplete = true;
		break;

	case PickThirdTote:
		SmartDashboard::PutString("AutoStep", "PickThirdTote");
		x = 0;
		y = 0;
		useDriveParams = true;
		stackerControl->SetLiftPosition(8);
		autoStepComplete = true;
		break;

	case WaitForLift:
		SmartDashboard::PutString("AutoStep", "WaitForLift");
		x = 0;
		y = 0;
		useDriveParams = true;
		if(stackerControl->GetError() < 15000) {
			autoStepComplete = true;
		}
		break;

	case WaitForLiftCoast:
		SmartDashboard::PutString("AutoStep", "WaitForLiftCoast");
		x = .2;
		y = 0;
		useDriveParams = true;
		if(stackerControl->GetError() < 10000) {
			autoStepComplete = true;
		}
		break;

	case WaitForLiftFinal:
		SmartDashboard::PutString("AutoStep", "WaitForLiftCoast");
		x = 0;
		y = 0;
		useDriveParams = true;
		if(stackerControl->GetError() < 100) {
			autoStepComplete = true;
		}
		break;

	case Turn90:
		SmartDashboard::PutString("AutoStep", "Turn90");
		useDriveParams = false;
		driveBase->DriveControlTwist->SetSetpoint(90);
		driveBase->DriveControlTwist->SetPID(.2, 0, 1.5);
		driveBase->DriveControlTwist->SetOutputRange(-.4, .4);
		driveBase->Steer(2.75,-driveBase->CrabSpeedTwist->Get(),1.1);
		if(fabs(driveBase->DriveControlTwist->GetError()) < 2) {
			onTargetCounter++;
		}

		if (onTargetCounter > 2) {
			autoStepComplete = true;
		}

		break;

	case CrabAwayFromWall:
		SmartDashboard::PutString("AutoStep", "CrabAwayFromWall");
		y = -.05*(autoFarUSDistanceToWall - driveBase->leftUS->GetDistance1());
		if (y<-.4)
			y=-.4;
		if (y>.4)
			y=.4;
		x = 0;
		robotAngle = 90;
		driveBase->DriveControlTwist->SetPID(.01, 0, .15);
		driveBase->DriveControlTwist->SetOutputRange(-.2, .2);
		useDriveParams = true;
		if(fabs(autoFarUSDistanceToWall - driveBase->leftUS->GetDistance1()) < 2) {
			onTargetCounter++;
			if(onTargetCounter > 5) {
				autoStepComplete = true;
			}
		}
		break;

	case DrivePastContainer:
		SmartDashboard::PutString("AutoStep", "DrivePastContainer");
		if(driveBase->leftUS->GetDistance2() > 65) {
			y = -.05*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
			if (y<-.4)
				y=-.4;
			if (y>.4)
				y=.4;
		}
		else
			y = 0;
		x = 0;
		x = .6;
		useDriveParams = true;
		robotAngle = 90;
		driveBase->DriveControlTwist->SetPID(.01, 0, 0);
		if(GetClock() - autoStepTime > .5) {
			autoStepComplete = true;
		}
		break;
		break;



	case CrabToWall:
		SmartDashboard::PutString("AutoStep", "CrabToWall");
		y = -.05*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
		if (y<-.4)
			y=-.4;
		if (y>.4)
			y=.4;
		x = 0;
		robotAngle = 90;
		driveBase->DriveControlTwist->SetPID(.01, 0, .15);
		driveBase->DriveControlTwist->SetOutputRange(-.2, .2);
		useDriveParams = true;
		if(fabs(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2()) < 2) {
			onTargetCounter++;
			if(onTargetCounter > 5) {
				autoStepComplete = true;
			}
		}
		break;

	case DriveForward15:
		SmartDashboard::PutString("AutoStep", "DriveForward15");
		if(driveBase->leftUS->GetDistance1() > 65)
			y = -.008*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance1());
		else if (driveBase->leftUS->GetDistance2() > 65)
			y = -.008*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
		else
			y = 0;
		if (y<-.1)
			y=-.1;
		if (y>.1)
			y=.1;
		x = .5;
		useDriveParams = true;
		robotAngle = 90;
		driveBase->DriveControlTwist->SetPID(.02, 0, 0);
		if(GetClock() - autoStepTime > .5) {
			autoStepComplete = true;
		}
		break;

	case ForwardToTote:
		SmartDashboard::PutString("AutoStep", "ForwardToTote");
		if(driveBase->leftUS->GetDistance1() > 65)
			y = -.008*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance1());
		else if (driveBase->leftUS->GetDistance2() > 65)
			y = -.008*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
		else
			y = 0;
		if (y<-.1)
			y=-.1;
		if (y>.1)
			y=.1;
		x = 0.2;
		useDriveParams = true;
		driveBase->DriveControlTwist->SetPID(.005, 0, 0);
		if((GetClock() - autoStepTime > .5) && (driveBase->toteWideLeft->Get() || driveBase->toteWideRight->Get())) {
			autoStepComplete = true;
		}
		break;

	case ForwardToThirdTote:
		SmartDashboard::PutString("AutoStep", "ForwardToThirdTote");
		if(driveBase->leftUS->GetDistance2() > 65) {
			y = -.05*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
			if (y<-.4)
				y=-.4;
			if (y>.4)
				y=.4;
		}
		else
			y = 0;
		x = 0.2;
		useDriveParams = true;
		driveBase->DriveControlTwist->SetPID(.002, 0, 0);
		if((GetClock() - autoStepTime > .5) && (driveBase->toteWideLeft->Get() || driveBase->toteWideRight->Get())) {
			autoStepComplete = true;
		}
		break;

	case ForwardToToteFinal:
		SmartDashboard::PutString("AutoStep", "ForwardToToteFinal");
		y =-.01*(autoleftUSDistanceToWall - driveBase->leftUS->GetDistance2());
		if (y<-.1)
			y=-.1;
		if (y>.1)
			y=.1;
		x = 0.2;
		useDriveParams = true;
		driveBase->DriveControlTwist->SetPID(.002, 0, 0);
		if((GetClock() - autoStepTime > .5) && (driveBase->toteWideLeft->Get() || driveBase->toteWideRight->Get())) {
			autoStepComplete = true;
		}
		break;


	case DriveToAutoZone1:
		SmartDashboard::PutString("AutoStep", "DriveToAutoZone");
		x = 0;
		y = -.6;
		useDriveParams = true;
		if(GetClock() - autoStepTime > 1.5) {
			autoStepComplete = true;
		}
		break;

	case DriveToAutoZone2:
		SmartDashboard::PutString("AutoStep", "DriveToAutoZone");
		x = 0;
		y = -.3;
		useDriveParams = true;
		if(GetClock() - autoStepTime > .75) {
			autoStepComplete = true;
			stacker->dart->Set(300);
		}
		break;


	case DropTotes:
		SmartDashboard::PutString("AutoStep", "DropTotes");
		x = -.1;
		y = 0;
		useDriveParams = true;
		stackerControl->LiftOpenLoop(-.2);
		if(stacker->liftFrontRight->GetPosition() < 57000) {
			autoStepComplete = true;
			stackerControl->LiftOpenLoop(0);
			stacker->dart->Set(dartVert);
		}
		break;

	case WaitForDart:
		SmartDashboard::PutString("AutoStep", "WaitForDart");
		x = 0;
		y = 0;
		useDriveParams = true;
		if(fabs(stacker->dart->GetClosedLoopError()) < 10) {
			autoStepComplete = true;
		}
		break;

	case DartBack:
		SmartDashboard::PutString("AutoStep", "DartBack");
		x = 0;
		y = 0;
		useDriveParams = true;
		stacker->dart->Set(900);
		autoStepComplete = true;
		break;

	case End:
		SmartDashboard::PutString("AutoStep", "End");
		x = 0;
		y = 0;
		useDriveParams = false;
		if(autoStart > 0) {
			SmartDashboard::PutNumber("AutonomousTime", GetClock() - autoStart);
			autoStart = 0;
		}
		Robot::driveBase->Lock();
		break;

	case ExtendGrabber:
		SmartDashboard::PutString("AutoStep", "ExtendGrabber");
		x = 0;
		y = 0;
		useDriveParams = false;
		driveBase->Lock();
		grabber->extension->Set(1.0);

		if (pdp->GetCurrent(9) > 50 && GetClock() - autoStepTime > .5)
			autoCurrentStop++;
		if(autoCurrentStop > 10)
			autoStepComplete = true;
		break;

	case RetractGrabber:
		SmartDashboard::PutString("AutoStep", "RetractGrabber");
		x = 0;
		y = 0;
		useDriveParams = false;
		driveBase->Lock();
		grabber->extension->Set(-1.0);
		if (pdp->GetCurrent(9) > 40 && GetClock() - autoStepTime > .25) {
			autoStepComplete = true;
			grabber->extension->Set(0);
		}
		break;

	case DriveOverBump:
		SmartDashboard::PutString("AutoStep", "DriveOverBump");
		x = 0;
		y = 1.0;
		robotAngle = 0;
		grabber->extension->Set(-1.0);
		useDriveParams = true;
		if (GetClock() - autoStepTime > 1.0) {
			autoStepComplete = true;
			grabber->extension->Set(0);
			stacker->dart->Set(dartVert);
		}
		break;

	case DriveAwayFromBumpWithCont:
		SmartDashboard::PutString("AutoStep", "DriveAwayFromBumpWithCont");
		x = 0;
		y = 1.0;
		robotAngle = -90;
		useDriveParams = true;
		if (GetClock() - autoStepTime > .5) {
			autoStepComplete = true;
			grabber->extension->Set(0);
		}
		break;

	case FinishTurn:
		SmartDashboard::PutString("AutoStep", "FinishTurn");
		x = 0;
		y = 0;
		useDriveParams = true;
		if (driveBase->DriveControlTwist->GetError() < 5) {
			autoStepComplete = true;
		}
		break;
	}

	if(useDriveParams) {
		driveBase->DriveControlTwist->SetSetpoint(robotAngle);
		driveBase->Crab(driveBase->CrabSpeedTwist->Get(), y, x, true);
	}

	/***********************Increment Through Program****************************/
	if (autoStepComplete) {
		autoStepTime = GetClock();
		autoCurrentStop = 0;
		autoStepComplete = false;
		autoStepi ++;
		autoStep = genericAutoProgram.at(autoStepi);
	}
}

void Robot::TeleopInit() {
	stackerControl->SetDartClosedLoop(true);
	stacker->dart->SetControlMode(CANSpeedController::kPosition);
	stacker->dart->Set(stacker->dart->GetPosition());
	stackerControl->LiftOpenLoop(0);
	stackerControl->SetAutoSpeed(false);
}

void Robot::TeleopPeriodic() {

	SmartDashboard::PutBoolean("LiftSmokedB",!stackerControl->GetSmoked());
	SendArduinoOutputs();
	/*******************SmartDashboard*********************/
	if(oi->getDriverRight()->GetRawButton(7))
		StackerSMDB();
	if(oi->getDriverRight()->GetRawButton(8))
		DriveBaseSMDB();
	if(oi->getDriverRight()->GetRawButton(9))
		SystemSMDB();
	/**************DRIVEBASE************************/

	//Resets gyro to zero when crab starts
	if (!prevTrigger && oi->getDriverRight()->GetRawButton(1)) {
		driveBase->imu->ZeroYaw();
	}
	prevTrigger = oi->getDriverRight()->GetRawButton(1);

	if(oi->getDriverLeft()->GetRawButton(1))
		driveBase->Lock();

	else if(oi->getDriverRight()->GetRawButton(2)) {
		centerTote->Start();
	}
	else {
		centerTote->Pause();
		centerTote->Reset();
		if(oi->getDriverLeft()->GetRawButton(1) && oi->getDriverRight()->GetMagnitude() < .1)
		{
			driveBase->Lock();
		}
		else if(oi->getDriverRight()->GetRawButton(1))
		{
			driveBase->Crab(oi->getJoystickTwist(),-oi->getJoystickY(),oi->getJoystickX(),true);
		}
		else if (oi->getDriverLeft()->GetRawButton(2)) {
			driveBase->Steer(3.14159,oi->getDriverLeft()->GetX(),2.1);
		}
		else
		{
			driveBase->Steer(oi->getLeftJoystickXRadians(),oi->getJoystickY(),.5);
		}
	}


	/**************STACKER************************/

	if(driveBase->imu->GetPitch() < -3 && !oi->getGamePad()->GetRawButton(8)) {
		pitchControlCounter++;
	}
	else
		pitchControlCounter = 0;

	if (fabs(oi->getGamePad()->GetRawAxis(3)) > .1 && stackerControl->GetDartClosedLoop()) {
		stackerControl->SetDartClosedLoop(false);
		stacker->dart->SetControlMode(CANSpeedController::kPercentVbus);
		dartPitchControl = false;
	}

	if(oi->getGamePad()->GetRawButton(6)) {

		if (!stackerControl->GetDartClosedLoop()) {
			stackerControl->SetDartClosedLoop(true);
			stacker->dart->SetControlMode(CANSpeedController::kPosition);
			dartPitchControl = false;
		}
		stacker->dart->Set(dartVert);
	}

	else if(!stackerControl->GetDartClosedLoop())
		stacker->dart->Set(oi->getGamePad()->GetRawAxis(3));

	if (pitchControlCounter > 20)	{
		if(!dartPitchControl) {
			stacker->dart->SetControlMode(CANSpeedController::kPosition);
			stackerControl->SetDartClosedLoop(true);
			stacker->dart->Set(dartBumpPos);
			dartPitchControl = true;
		}
	}
	else if (dartPitchControl){
		stacker->dart->Set(dartVert);
		dartPitchControl = false;
	}

	if(oi->getGamePad()->GetRawButton(4)) {
		stacker->dart->SetControlMode(CANSpeedController::kPosition);
		stackerControl->SetDartClosedLoop(true);
		stacker->dart->Set(dartFullBack);
		dartPitchControl = false;
		stackerControl->SetLiftPosition(9);
	}


//IncLift
	if(oi->getGamePad()->GetRawButton(5) || oi->getDriverRight()->GetRawButton(3)) {
		if (!pressed5) {
		stackerControl->IncLiftPosition();
		pressed5 = true;
		}
	}
	else
		pressed5 = false;


//LiftContainer
	if(oi->getDriverRight()->GetRawButton(4))
		stackerControl->SetLiftPosition(4);

//DecLift
	if (oi->getGamePad()->GetRawButton(7)) {
		if (!pressed7) {
			stackerControl->DecLiftPoistion();
			pressed7 = true;
			}
	}
	else
		pressed7 = false;

//Automated Release
	if(oi->getGamePad()->GetRawButton(2)) {
		if(!pressed2) {
			stackerControl->Release();
			pressed2 = true;
		}
	}
	else
		pressed2 = false;

//Home Lift
	if (oi->getGamePad()->GetPOV(0) == 180) {
		stackerControl->Home();

		if (!stackerControl->GetDartClosedLoop()) {
			stackerControl->SetDartClosedLoop(true);
			stacker->dart->SetControlMode(CANSpeedController::kPosition);
		}
		stacker->dart->Set(dartContPickPos);

	}

//Lift Open Loop
	if (fabs(oi->getGamePad()->GetRawAxis(1)) > .1) {
		stackerControl->LiftOpenLoop(-oi->getScaledJoystick(oi->getGamePad()->GetRawAxis(1),3));
		liftUsingJoystick = true;
	}
	else if(liftUsingJoystick) {
		stackerControl->LiftOpenLoop(0);
		liftUsingJoystick = false;
	}

	if(oi->getGamePad()->GetPOV() == 270)
		squeezeControl->Close(false);
	if(oi->getGamePad()->GetPOV() == 90)
		squeezeControl->Open();


	/**************GRABBER************************/
	if(oi->getGamePad()->GetRawButton(3))
		grabber->extension->Set(-1.0);
	else if (oi->getGamePad()->GetRawButton(1))
		grabber->extension->Set(1.0);
	else
		grabber->extension->Set(0.0);

}

void Robot::TestPeriodic() {
	lw->Run();
}

void Robot::SystemSMDB() {
	SmartDashboard::PutNumber("FrontLeftDriveCurrentPDP",pdp->GetCurrent(14));
	SmartDashboard::PutNumber("RearLeftDriveCurrentPDP",pdp->GetCurrent(15));
	SmartDashboard::PutNumber("FrontRightDriveCurrentPDP",pdp->GetCurrent(1));
	SmartDashboard::PutNumber("RearRightDriveCurrentPDP",pdp->GetCurrent(0));

	SmartDashboard::PutNumber("FrontLeftSteerCurrentPDP",Robot::driveBase->frontLeftSteer->GetOutputCurrent());
	SmartDashboard::PutNumber("FrontRightSteerCurrentPDP",Robot::driveBase->frontRightSteer->GetOutputCurrent());
	SmartDashboard::PutNumber("RearLeftSteerCurrentPDP",Robot::driveBase->rearLeftSteer->GetOutputCurrent());
	SmartDashboard::PutNumber("RearRightSteerCurrentPDP",Robot::driveBase->rearRightSteer->GetOutputCurrent());

	SmartDashboard::PutNumber("GrabberCurrent", pdp->GetCurrent(9));

	SmartDashboard::PutNumber("DartCurrent", Robot::stacker->dart->GetOutputCurrent());
	SmartDashboard::PutNumber("SqueezerCurrent", Robot::stacker->squeeze->GetOutputCurrent());
	SmartDashboard::PutNumber("LiftRightCurrent", Robot::stacker->liftFrontRight->GetOutputCurrent());
	SmartDashboard::PutNumber("LiftLeftCurrent", Robot::stacker->liftFrontLeft->GetOutputCurrent());

	SmartDashboard::PutNumber("TotalEnergy", pdp->GetTotalEnergy());

}

void Robot::DriveBaseSMDB() {
	SmartDashboard::PutNumber("IMUYaw",driveBase->imu->GetYaw());
	SmartDashboard::PutNumber("IMUPitch",driveBase->imu->GetPitch());
	SmartDashboard::PutNumber("IMURoll",driveBase->imu->GetRoll());
	SmartDashboard::PutNumber("FrontLeftSteerCurrent",driveBase->frontRightSteer->GetOutputCurrent());
	SmartDashboard::PutNumber("frontleftvolt",driveBase->frontLeftPos->GetAverageVoltage());
	SmartDashboard::PutNumber("rearleftvolt",driveBase->rearLeftPos->GetAverageVoltage());
	SmartDashboard::PutNumber("frontrightvolt",driveBase->frontRightPos->GetAverageVoltage());
	SmartDashboard::PutBoolean("ToteWideLeftB", driveBase->toteWideLeft->Get());
	SmartDashboard::PutBoolean("ToteNarrowLeftB", driveBase->toteNarrowLeft->Get());
	SmartDashboard::PutBoolean("ToteNarrowRightB", driveBase->toteNarrowRight->Get());
	SmartDashboard::PutBoolean("ToteWideRightB", driveBase->toteWideRight->Get());
	SmartDashboard::PutNumber("UltrasonicDistanceLeft1(Mid)", driveBase->leftUS->GetDistance1());
	SmartDashboard::PutNumber("UltrasonicDistanceLeft2(Front)", driveBase->leftUS->GetDistance2());
	SmartDashboard::PutNumber("JoystickRadians", oi->getLeftJoystickXRadians());

}

void Robot::StackerSMDB() {
	SmartDashboard::PutNumber("DartPosition",stacker->dart->GetAnalogIn());
	SmartDashboard::PutNumber("LitPosition",stacker->liftFrontLeft->GetEncPosition());
	SmartDashboard::PutNumber("SqueezePosition", stacker->squeezePosition->GetDistance());
	SmartDashboard::PutNumber("SqueezeRawPosition", stacker->squeezePosition->GetRaw());
	SmartDashboard::PutBoolean("StackerHomeSwitch", stacker->home->Get());
	SmartDashboard::PutNumber("SqueezeOutput", stacker->squeeze->Get());
	SmartDashboard::PutNumber("LiftPosition", stacker->liftFrontRight->GetPosition());
	SmartDashboard::PutNumber("LiftError", stackerControl->GetError());
	SmartDashboard::PutNumber("i", stackerControl->Geti());
	SmartDashboard::PutBoolean("StackerHoming", stackerControl->GetHoming());
	SmartDashboard::PutBoolean("DartForwardLimitSwitch", Robot::stacker->dart->GetForwardLimitOK());
	SmartDashboard::PutBoolean("DartReverseLimitSwitch", Robot::stacker->dart->GetReverseLimitOK());
}

void Robot::SendArduinoOutputs() {
	Robot::arduino->sensorLeft->Set(!Robot::driveBase->toteWideLeft->Get());
	Robot::arduino->sensorMiddleLeft->Set(!Robot::driveBase->toteNarrowLeft->Get());
	Robot::arduino->sensorMiddleRight->Set(!Robot::driveBase->toteNarrowRight->Get());
	Robot::arduino->sensorRight->Set(!Robot::driveBase->toteWideRight->Get());
	Robot::arduino->sensorMiddle->Set(squeezeControl->GetOpened());
	Robot::arduino->robotState1->Set(DriverStation::GetInstance()->GetAlliance() == DriverStation::kBlue);
	Robot::arduino->robotState2->Set(DriverStation::GetInstance()->GetAlliance() == DriverStation::kRed);
}

bool Robot::ReadyForPickup() {
	if(!(Robot::driveBase->toteWideLeft->Get() &&
			Robot::driveBase->toteNarrowLeft->Get() &&
			Robot::driveBase->toteNarrowRight->Get() &&
			Robot::driveBase->toteWideRight->Get())) {
		pickupStartTime = GetClock();
	}

	return GetClock() - pickupStartTime > .2;
}

START_ROBOT_CLASS(Robot);

